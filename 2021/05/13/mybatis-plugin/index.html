<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>这么强大的Mybatis插件机制原来就是这？ | 墨鱼🦑的个人博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 6.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">这么强大的Mybatis插件机制原来就是这？</h1><a id="logo" href="/.">墨鱼🦑的个人博客</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">这么强大的Mybatis插件机制原来就是这？</h1><div class="post-meta">2021-05-13</div><div class="post-content"><p>Mybatis开发中经常会用到pagehelper分页插件，除此之外还有慢sql上报等各种各样的插件，那么Mybatis是如何来实现如此强大的插件机制呢？一起来看看吧。</p>
<span id="more"></span>
<h2 id="Mybatis插件机制介绍"><a href="#Mybatis插件机制介绍" class="headerlink" title="Mybatis插件机制介绍"></a>Mybatis插件机制介绍</h2><p>MyBatis 允许你在映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：</p>
<ul>
<li>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</li>
</ul>
<p>执行器，提供操作数据库的接口。</p>
<ul>
<li>ParameterHandler (getParameterObject, setParameters)</li>
</ul>
<p>参数处理器，设置sql的参数。</p>
<ul>
<li>ResultSetHandler (handleResultSets, handleOutputParameters)</li>
</ul>
<p>结果集处理器，处理从数据库查询的结果集，封装成对象等。</p>
<ul>
<li>StatementHandler (prepare, parameterize, batch, update, query)</li>
</ul>
<p>语法处理器，真正去执行数据库CRUD。</p>
<p>他们的引用关系如下<br><img src="https://img-blog.csdnimg.cn/20210518153023684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE4NTE1MTU1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可见其插件是基于<strong>方法拦截</strong>来实现的！我们姑且猜测是和AOP有关，到底对不对呢，往下看就知道了。</p>
<h2 id="自定义一个Mybatis插件"><a href="#自定义一个Mybatis插件" class="headerlink" title="自定义一个Mybatis插件"></a>自定义一个Mybatis插件</h2><p>自定义一个插件是如此简单，以拦截<code>ResultSetHandler</code>为例，仅需要两步（Mybatis版本：3.5.6）：</p>
<p>步骤一：实现Interceptor接口，如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mybatisplugin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.executor.resultset.ResultSetHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.plugin.Interceptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.plugin.Intercepts;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.plugin.Invocation;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.plugin.Signature;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xujian</span></span><br><span class="line"><span class="comment"> * 2021-05-11 15:22</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Intercepts(@Signature(type = ResultSetHandler.class,//指定你要拦截是哪个对象</span></span><br><span class="line"><span class="meta">        method = &quot;handleResultSets&quot;,//指定你要拦截的是哪个方法</span></span><br><span class="line"><span class="meta">        args = &#123;Statement.class&#125;))</span><span class="comment">//考虑到方法重载，还需要指定参数列表</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPlugin</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        log.info(<span class="string">&quot;----插件拦截到handleResultSets----&quot;</span>);</span><br><span class="line">        <span class="comment">//实行原始的方法调用</span></span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤二：在Mybatis的配置文件加入自定义插件的配置，如下所示</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;mybatisplugin.MyPlugin&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，当执行了数据库查询操作，调用<code>ResultSetHandler#handleResultSets</code>封装返回结果集之前会打印日志，如下图所示<br><img src="https://img-blog.csdnimg.cn/20210518153234753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE4NTE1MTU1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="插件执行原理分析"><a href="#插件执行原理分析" class="headerlink" title="插件执行原理分析"></a>插件执行原理分析</h2><h3 id="插件定义"><a href="#插件定义" class="headerlink" title="插件定义"></a>插件定义</h3><p>实现<code>Interceptor</code>，其源码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截器接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截方法，自定义插件需要实现的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation 调用信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 调用结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable 若发生异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用插件。如应用成功，则会创建目标对象的代理对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 目标对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 应用的结果对象，可以是代理对象，也可以是 target 对象，也可以是任意对象。具体的，看代码实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> Object <span class="title function_">plugin</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(target, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置插件属性</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;plugin&gt;标签的properties 属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插件是定义好了，那插件是在什么时候生效的呢？</p>
<h3 id="插件初始化"><a href="#插件初始化" class="headerlink" title="插件初始化"></a>插件初始化</h3><p>当在配置文件配置上自定义插件以后，mybatis在初始化解析配置文件的时候，就会解析<plugin>标签。</p>
<p><code>XMLConfigBuilder#parseConfiguration</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseConfiguration</span><span class="params">(XNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 解析 &lt;plugins /&gt; 标签</span></span><br><span class="line">            pluginElement(root.evalNode(<span class="string">&quot;plugins&quot;</span>));</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Error parsing SQL Mapper Configuration. Cause: &quot;</span> + e, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>去到真正解析<plugin>标签的方法<code>XMLConfigBuilder#pluginElement</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pluginElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 遍历 &lt;plugins /&gt; 标签</span></span><br><span class="line">            <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">              	<span class="comment">//从xml的interceptor属性中解析出插件的名称（包名+类名即全限定名）</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">interceptor</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;interceptor&quot;</span>);</span><br><span class="line">              	<span class="comment">//1、从xml配置文件解析出来插件的配置</span></span><br><span class="line">                <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> child.getChildrenAsProperties();</span><br><span class="line">                <span class="comment">//2、创建 Interceptor 对象，并设置属性</span></span><br><span class="line">                <span class="type">Interceptor</span> <span class="variable">interceptorInstance</span> <span class="operator">=</span> (Interceptor) resolveClass(interceptor).newInstance();</span><br><span class="line">              	<span class="comment">//3、给插件对象设置上插件配置的属性</span></span><br><span class="line">                interceptorInstance.setProperties(properties);</span><br><span class="line">                <span class="comment">//4、添加到 configuration 中</span></span><br><span class="line">                configuration.addInterceptor(interceptorInstance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>注意到上面的第2步，该步骤是通过反射创建出插件对象的实例，也就是MyPlugin对象。</p>
<p>跟踪<code>resolveClass</code>方法，最后发现实际上是调用的<code>TypeAliasRegistry#resolveAlias</code></p>
<p>具体来看代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*参数是插件的全限定名</span></span><br><span class="line"><span class="comment">返回插件的Class对象</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Class&lt;T&gt; <span class="title function_">resolveAlias</span><span class="params">(String string)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (string == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// issue #748</span></span><br><span class="line">            <span class="comment">// 转换成小写</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> string.toLowerCase(Locale.ENGLISH);</span><br><span class="line">            Class&lt;T&gt; value;</span><br><span class="line">            <span class="keyword">if</span> (TYPE_ALIASES.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">//首先，从 TYPE_ALIASES（别名注册表） 中获取，如果配置了别名，</span></span><br><span class="line">          	<span class="comment">//那么配置插件的时候就不需要配置全限定名，只需要配置类名即可，</span></span><br><span class="line">          	<span class="comment">//那么就会走到该分支</span></span><br><span class="line">                value = (Class&lt;T&gt;) TYPE_ALIASES.get(key);</span><br><span class="line">            <span class="comment">// 其次，直接获得对应类</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                value = (Class&lt;T&gt;) Resources.classForName(string);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123; <span class="comment">// 异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeException</span>(<span class="string">&quot;Could not resolve type alias &#x27;&quot;</span> + string + <span class="string">&quot;&#x27;.  Cause: &quot;</span> + e, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>经过上述过程就拿到了插件的实例对象，然后走到步骤4，该步骤是将插件设置到全局配置类<code>Configuration</code>中。</p>
<p>跟踪<code>addInterceptor</code>方法，发现其最终调用的是<code>InterceptorChain#addInterceptor</code>，而<code>Configuration</code>中就持有<code>InterceptorChain</code>的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截器链</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterceptorChain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截器数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用所有插件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 目标对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 应用结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">pluginAll</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">            target = interceptor.plugin(target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptor</span><span class="params">(Interceptor interceptor)</span> &#123;</span><br><span class="line">        interceptors.add(interceptor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Interceptor&gt; <span class="title function_">getInterceptors</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableList(interceptors);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>InterceptorChain</code>内部维护了一个<code>Interceptor</code>列表，用来存放所有自定义的插件。</p>
<h3 id="插件如何生效"><a href="#插件如何生效" class="headerlink" title="插件如何生效"></a>插件如何生效</h3><p>注意到上面自定义的插件类上有如下注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts(@Signature(type = ResultSetHandler.class,//指定你要拦截是哪个对象</span></span><br><span class="line"><span class="meta">        method = &quot;handleResultSets&quot;,//指定你要拦截的是哪个方法</span></span><br><span class="line"><span class="meta">        args = &#123;Statement.class&#125;))</span><span class="comment">//考虑到方法重载，还需要指定参数列表</span></span><br></pre></td></tr></table></figure>

<p>该注解声明了该插件生效的时机：mybatis在调用<code>ResultSetHandler#handleResultSets(Statement stmt)</code>方法时会执行插件逻辑。</p>
<p>实际上<code>ResultSetHandler</code>是一个接口，它的默认实现类是<code>DefaultResultSetHandler</code>。</p>
<p>我们知道，mybatis最终是通过<code>ResultSetHandler</code>来处理从数据库查询的结果的，</p>
<p>那就来找到创建<code>ResultSetHandler</code>的地方</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 ResultSetHandler 对象</span></span><br><span class="line">    <span class="keyword">public</span> ResultSetHandler <span class="title function_">newResultSetHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,</span></span><br><span class="line"><span class="params">                                                ResultHandler resultHandler, BoundSql boundSql)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、创建 DefaultResultSetHandler 对象</span></span><br><span class="line">        <span class="type">ResultSetHandler</span> <span class="variable">resultSetHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultResultSetHandler</span>(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">        <span class="comment">// 2、应用插件</span></span><br><span class="line">        resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">        <span class="keyword">return</span> resultSetHandler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>重点关注步骤2，在步骤1创建了一个<code>DefaultResultSetHandler</code>创建了一个默认的<code>ResultSetHandler</code>实现以后，调用了<code>InterceptorChain#pluginAll</code>方法，继续跟踪该方法，最终发现是遍历<code>InterceptorChain</code>保存的所有的插件，然后逐个调用插件的<code>plugin</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用所有插件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 目标对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 应用结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">pluginAll</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">            target = interceptor.plugin(target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>紧接着再来看看<code>Interceptor#plugin</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">plugin</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(target, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>内部调用了<code>Plugin</code>类的静态<code>wrap</code>方法</p>
<p>高能来了！高能来了！高能来了！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建目标类的代理对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 目标类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interceptor 拦截器对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> &#123;</span><br><span class="line">        <span class="comment">// 获得拦截的方法映射，哪个类的哪些方法需要被拦截</span></span><br><span class="line">        Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">        <span class="comment">// 获得目标类的类型</span></span><br><span class="line">        Class&lt;?&gt; type = target.getClass();</span><br><span class="line">        <span class="comment">// 获得目标类的接口集合</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">        <span class="comment">// 若有接口，则创建目标对象的 JDK Proxy 对象</span></span><br><span class="line">        <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                    type.getClassLoader(),</span><br><span class="line">                    interfaces,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Plugin</span>(target, interceptor, signatureMap)); <span class="comment">// 因为 Plugin 实现了 InvocationHandler 接口，所以可以作为 JDK 动态代理的调用处理器</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有，则返回原始的目标对象</span></span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>Proxy.newProxyInstance(type.getClassLoader(),interfaces,new Plugin(target, interceptor, signatureMap));</code></p>
<p>这行代码难道你不熟悉吗，没错，这正是<strong>JDK动态代理</strong>的写法。</p>
<blockquote>
<p>从这里可以看出来mybatis创建的ResultSetHandler对象其实是经过层层代理过的对象。</p>
</blockquote>
<p>那既然是JDK动态代理，那就应该有对<code>InvocationHandler</code>的实现，是谁呢？</p>
<p>看看<code>Plugin</code>这个类的定义<code>public class Plugin implements InvocationHandler</code>会发现就是它了。</p>
<p>紧接着来看看<code>InvocationHandler</code>最重要的<code>invoke</code>方法的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 当前方法所属的类有哪些需要被拦截的方法</span></span><br><span class="line">            Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</span><br><span class="line">            <span class="keyword">if</span> (methods != <span class="literal">null</span> &amp;&amp; methods.contains(method)) &#123;</span><br><span class="line">                <span class="comment">// 1、如果当前方法包含在要被拦截的方法之内，则拦截处理该方法</span></span><br><span class="line">                <span class="keyword">return</span> interceptor.intercept(<span class="keyword">new</span> <span class="title class_">Invocation</span>(target, method, args));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2、如果不是，则调用原方法</span></span><br><span class="line">            <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>如果当前方法要被拦截，那就调用插件的<code>intercept</code>方法；</li>
<li>如果当前方法不需要被拦截，那就直接调用原始对象的对应方法；</li>
</ol>
<p>看到这里就豁然开朗了，原来自定义插件时实现的<code>intercept</code>方法是在这里被调用了。</p>
<h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2><p>现在来整理一下思路：</p>
<p>1、将自定义插件保存到<strong>插件链</strong>中；<br><img src="https://img-blog.csdnimg.cn/20210518153059983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE4NTE1MTU1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2、使用插件链中的插件层层代理<code>ResultSetHandler</code>；<br><img src="https://img-blog.csdnimg.cn/20210518153124699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE4NTE1MTU1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3、调用插件的<code>intercept</code>方法；<br><img src="https://img-blog.csdnimg.cn/20210609193640498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE4NTE1MTU1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过上面的分析，发现Mybatis的插件机制主要还是依赖于JDK动态代理，更抽象一点说是依赖于AOP思想，其核心就是“拦截+增强”，那其实除了Mybatis的插件机制，Skywalking的插件机制也是基于这种思想实现的，可以参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_18515155/article/details/114454166">Skywalking如何通过修改字节码让插件生效</a>。</p>
<p>工作中我们也可以尝试借鉴这种思想来扩展我们的业务服务。</p>
<p>最后让我们一起喊出：<strong>动态代理，yyds！</strong></p>
<hr>
<p>相关代码请参考：<a target="_blank" rel="noopener" href="https://github.com/xujian01/blogcode/tree/master/src/main/java/mybatisplugin">https://github.com/xujian01/blogcode/tree/master/src/main/java/mybatisplugin</a></p>
</div><div class="tags"><a href="/tags/Mybatis/"><i class="fa fa-tag"></i>Mybatis</a></div><div class="post-nav"><a class="pre" href="/2021/06/15/enhance-jdk-proxy-v1/">实现一个增强版的JDK动态代理V1.0</a><a class="next" href="/2021/05/10/spring-circle-depence/">探索Spring循环依赖的细节</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://example.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Apollo/" style="font-size: 15px;">Apollo</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/Canal/" style="font-size: 15px;">Canal</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Mybatis/" style="font-size: 15px;">Mybatis</a> <a href="/tags/RocketMQ/" style="font-size: 15px;">RocketMQ</a> <a href="/tags/Gson/" style="font-size: 15px;">Gson</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 15px;">多线程</a> <a href="/tags/GitLab/" style="font-size: 15px;">GitLab</a> <a href="/tags/WebHook/" style="font-size: 15px;">WebHook</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/Swagger/" style="font-size: 15px;">Swagger</a> <a href="/tags/ServiceMesh/" style="font-size: 15px;">ServiceMesh</a> <a href="/tags/Skywalking/" style="font-size: 15px;">Skywalking</a> <a href="/tags/ES/" style="font-size: 15px;">ES</a> <a href="/tags/MongoDB/" style="font-size: 15px;">MongoDB</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/06/25/print-xyz/">使用三个线程，按顺序打印X，Y，Z，连续打印10次</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/06/19/enhance-jdk-proxy-v2/">实现一个增强版的JDK动态代理V2.0</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/06/15/enhance-jdk-proxy-v1/">实现一个增强版的JDK动态代理V1.0</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/13/mybatis-plugin/">这么强大的Mybatis插件机制原来就是这？</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/10/spring-circle-depence/">探索Spring循环依赖的细节</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/12/skywalking-plugin-principle/">Skywalking如何通过修改字节码让插件生效</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/26/gson-serialize-fail/">Gson序列化LinkedHashMap.Entry失败的探索</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/20/springboot-es-mongodb/">SpringBoot中使用ES和MongoDB常用API</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/20/java-complier-optimization/">又长见识了！JVM编译优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/15/swagger+yapi/">Swagger API Spec + Swagger Codegen + YAPI管理接口文档</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://blog.csdn.net/qq_18515155" title="CSDN-徐小陌的博客" target="_blank">CSDN-徐小陌的博客</a><ul></ul><a href="https://www.zhihu.com/people/xu-jian-1-1" title="知乎-倔强的码农" target="_blank">知乎-倔强的码农</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">墨鱼🦑的个人博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>